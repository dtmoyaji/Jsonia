/**
 * Jsonia Runtime Actions Library
 * „Ç¢„ÇØ„Ç∑„Éß„É≥ÂÆüË£Ö„ÇíJsoniaRuntime„Å´ËøΩÂä†„Åô„Çã„Éü„ÉÉ„ÇØ„Çπ„Ç§„É≥
 */

/**
 * JsoniaRuntime„Å´„Ç¢„ÇØ„Ç∑„Éß„É≥„Éè„É≥„Éâ„É©„Éº„ÇíËøΩÂä†
 */
function extendJsoniaRuntimeWithActions(JsoniaRuntimeClass) {
    
    /**
     * Êã°ÂºµexecuteAction„É°„ÇΩ„ÉÉ„Éâ - „Ç¢„ÇØ„Ç∑„Éß„É≥„Éè„É≥„Éâ„É©„Éº„Çí„Éá„Ç£„Çπ„Éë„ÉÉ„ÉÅ
     */
    const originalExecuteAction = JsoniaRuntimeClass.prototype.executeAction;
    
    JsoniaRuntimeClass.prototype.executeAction = async function(action, event = null) {
        // „Ç´„Çπ„Çø„É†„Ç¢„ÇØ„Ç∑„Éß„É≥„Éè„É≥„Éâ„É©„Éº„ÇíÂÖà„Å´„ÉÅ„Çß„ÉÉ„ÇØ
        const handler = this.actionHandlers && this.actionHandlers[action.type];
        if (handler) {
            return await handler.call(this, action, event);
        }
        
        // ÂÖÉ„ÅÆexecuteAction„Å´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
        return await originalExecuteAction.call(this, action, event);
    };
    
    /**
     * „Ç¢„ÇØ„Ç∑„Éß„É≥„Éè„É≥„Éâ„É©„ÉºÁôªÈå≤
     */
    JsoniaRuntimeClass.prototype.registerActionHandler = function(type, handler) {
        if (!this.actionHandlers) {
            this.actionHandlers = {};
        }
        this.actionHandlers[type] = handler;
    };
    
    /**
     * „Åô„Åπ„Å¶„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Éè„É≥„Éâ„É©„Éº„ÇíÁôªÈå≤
     */
    JsoniaRuntimeClass.prototype.initializeActionHandlers = function() {
        // DOMÊìç‰Ωú
        this.registerActionHandler('dom.select', domSelect);
        this.registerActionHandler('dom.selectAll', domSelectAll);
        this.registerActionHandler('dom.createElement', domCreateElement);
        this.registerActionHandler('dom.setInnerHTML', domSetInnerHTML);
        this.registerActionHandler('dom.setTextContent', domSetTextContent);
        this.registerActionHandler('dom.setAttribute', domSetAttribute);
        this.registerActionHandler('dom.addClass', domAddClass);
        this.registerActionHandler('dom.removeClass', domRemoveClass);
        this.registerActionHandler('dom.toggleClass', domToggleClass);
        this.registerActionHandler('dom.appendChild', domAppendChild);
        this.registerActionHandler('dom.insertIntoSlot', domInsertIntoSlot);
        this.registerActionHandler('dom.removeChild', domRemoveChild);
        this.registerActionHandler('dom.remove', domRemove);
        this.registerActionHandler('dom.removeInnerDropZone', domRemoveInnerDropZone);
        this.registerActionHandler('dom.stopPropagation', domStopPropagation);
        this.registerActionHandler('dom.preventDefault', domPreventDefault);
        this.registerActionHandler('dom.addEventListener', domAddEventListener);
        this.registerActionHandler('dom.createFromHTML', domCreateFromHTML);
        this.registerActionHandler('dom.buildTree', domBuildTree);
        
        // ÈÖçÂàóÊìç‰Ωú
        this.registerActionHandler('array.forEach', arrayForEach);
        this.registerActionHandler('array.map', arrayMap);
        this.registerActionHandler('array.filter', arrayFilter);
        this.registerActionHandler('array.length', arrayLength);
        
        // „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÊìç‰Ωú
        this.registerActionHandler('object.set', objectSet);
        this.registerActionHandler('object.get', objectGet);
        
        // ÊñáÂ≠óÂàóÊìç‰Ωú
        this.registerActionHandler('string.template', stringTemplate);
        this.registerActionHandler('string.concat', stringConcat);
        
        // „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
        this.registerActionHandler('util.parseJSON', utilParseJSON);
        this.registerActionHandler('util.timestamp', utilTimestamp);
        this.registerActionHandler('util.delay', utilDelay);
        this.registerActionHandler('util.getAttribute', utilGetAttribute);
        this.registerActionHandler('util.closest', utilClosest);
        this.registerActionHandler('util.querySelector', utilQuerySelector);
        
        // „ÉÜ„É≥„Éó„É¨„Éº„Éà„Éª„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
        this.registerActionHandler('template.renderFromJSON', templateRenderFromJSON);
        this.registerActionHandler('component.renderList', componentRenderList);
                this.registerActionHandler('component.method', componentMethod.bind(this));
        this.registerActionHandler('registerComponentMethods', registerComponentMethods.bind(this));
        this.registerActionHandler('registerComponentActions', registerComponentActions.bind(this));
        
        // „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó
        this.registerActionHandler('drag.setData', dragSetData);
        this.registerActionHandler('drag.getData', dragGetData);
    };
}

// =====================================================
// DOMÊìç‰Ωú„Ç¢„ÇØ„Ç∑„Éß„É≥
// =====================================================

async function domSelect(action, event) {
    const selected = document.querySelector(this.resolveTemplate(action.selector));
    if (action.output) {
        this.setState(action.output, selected);
    }
    return selected;
}

async function domSelectAll(action, event) {
    const selectedAll = Array.from(document.querySelectorAll(this.resolveTemplate(action.selector)));
    if (action.output) {
        this.setState(action.output, selectedAll);
    }
    return selectedAll;
}

async function domCreateElement(action, event) {
    const newElement = document.createElement(action.tag || 'div');
    if (action.output) {
        this.setState(action.output, newElement);
    }
    return newElement;
}

async function domSetInnerHTML(action, event) {
    const htmlTarget = this.resolveValue(action.target);
    if (htmlTarget) {
        htmlTarget.innerHTML = this.resolveTemplate(action.value);
    }
}

async function domSetTextContent(action, event) {
    const textTarget = this.resolveValue(action.target);
    if (textTarget) {
        textTarget.textContent = this.resolveTemplate(action.value);
    }
}

async function domSetAttribute(action, event) {
    const attrTarget = this.resolveValue(action.target);
    if (attrTarget) {
        attrTarget.setAttribute(action.name, this.resolveTemplate(action.value));
    }
}

async function domAddClass(action, event) {
    const addClassTarget = this.resolveValue(action.target);
    if (addClassTarget) {
        addClassTarget.classList.add(action.className);
    }
}

async function domRemoveClass(action, event) {
    const removeClassTarget = this.resolveValue(action.target);
    if (removeClassTarget) {
        removeClassTarget.classList.remove(action.className);
    }
}

async function domToggleClass(action, event) {
    const toggleClassTarget = this.resolveValue(action.target);
    if (toggleClassTarget) {
        toggleClassTarget.classList.toggle(action.className);
    }
}

async function domAppendChild(action, event) {
    const parent = this.resolveValue(action.parent);
    const child = this.resolveValue(action.child);
    if (parent && child) {
        parent.appendChild(child);
    }
}

async function domInsertIntoSlot(action, event) {
    const container = this.resolveValue(action.container);
    const children = this.resolveValue(action.children);
    const slotName = action.slotName || 'children';
    
    if (container && children) {
        const success = this.insertIntoSlot(container, children, slotName);
        if (success) {
            console.log(`‚úÖ „Çπ„É≠„ÉÉ„Éà "${slotName}" „Å´Ë¶ÅÁ¥†„ÇíÊåøÂÖ•„Åó„Åæ„Åó„Åü`);
        } else {
            console.log(`‚ö†Ô∏è „Çπ„É≠„ÉÉ„Éà "${slotName}" „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ„Ç≥„É≥„ÉÜ„Éä„Å´Áõ¥Êé•ÊåøÂÖ•„Åó„Åæ„Åó„Åü`);
        }
        
        if (action.output) {
            this.setState(action.output, success);
        }
        return success;
    }
    return false;
}

async function domRemoveChild(action, event) {
    const removeParent = this.resolveValue(action.parent);
    const removeChild = this.resolveValue(action.child);
    if (removeParent && removeChild) {
        removeParent.removeChild(removeChild);
    }
}

async function domRemove(action, event) {
    const element = this.resolveValue(action.target);
    if (element && element.remove) {
        element.remove();
    }
}

async function domRemoveInnerDropZone(action, event) {
    const parent = this.resolveValue(action.parent);
    if (parent) {
        const innerDropZone = parent.querySelector('.inner-drop-zone');
        if (innerDropZone) {
            innerDropZone.remove();
            console.log('üóëÔ∏è ÂÜÖÈÉ®„Éâ„É≠„ÉÉ„Éó„Çæ„Éº„É≥„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
        }
    }
}

async function domStopPropagation(action, event) {
    if (event && event.stopPropagation) {
        event.stopPropagation();
    }
}

async function domPreventDefault(action, event) {
    if (event && event.preventDefault) {
        event.preventDefault();
    }
}

async function domAddEventListener(action, event) {
    const eventTarget = this.resolveValue(action.target);
    if (eventTarget && action.event && action.actions) {
        eventTarget.addEventListener(action.event, (e) => {
            this.executeActions(action.actions, e);
        });
    }
}

async function domCreateFromHTML(action, event) {
    const htmlString = this.resolveTemplate(action.html);
    const tempContainer = document.createElement('div');
    tempContainer.innerHTML = htmlString;
    const createdElement = tempContainer.firstChild;
    if (action.output) {
        this.setState(action.output, createdElement);
    }
    return createdElement;
}

async function domBuildTree(action, event) {
    const rootElement = this.resolveValue(action.root);
    const startLevel = action.level || 0;
    const treeHTML = this.buildTreeHTML(rootElement, startLevel, action.options || {});
    if (action.output) {
        this.setState(action.output, treeHTML);
    }
    return treeHTML;
}

// =====================================================
// ÈÖçÂàóÊìç‰Ωú„Ç¢„ÇØ„Ç∑„Éß„É≥
// =====================================================

async function arrayForEach(action, event) {
    const forEachArray = this.resolveValue(action.array);
    if (Array.isArray(forEachArray) && action.do) {
        for (let i = 0; i < forEachArray.length; i++) {
            const item = forEachArray[i];
            const oldValue = this.getState(action.item);
            const oldIndex = this.getState(action.index || 'index');
            
            this.setState(action.item, item);
            if (action.index) {
                this.setState(action.index, i);
            }
            
            await this.executeActions(action.do, event);
            
            if (oldValue !== undefined) this.setState(action.item, oldValue);
            if (oldIndex !== undefined) this.setState(action.index || 'index', oldIndex);
        }
    }
}

async function arrayMap(action, event) {
    const mapArray = this.resolveValue(action.array);
    if (Array.isArray(mapArray)) {
        const result = [];
        for (let i = 0; i < mapArray.length; i++) {
            const item = mapArray[i];
            const oldValue = this.getState(action.item);
            this.setState(action.item, item);
            
            await this.executeActions(action.do, event);
            const mappedValue = this.getState(action.output);
            result.push(mappedValue);
            
            if (oldValue !== undefined) this.setState(action.item, oldValue);
        }
        if (action.storeIn) {
            this.setState(action.storeIn, result);
        }
        return result;
    }
}

async function arrayFilter(action, event) {
    const filterArray = this.resolveValue(action.array);
    if (Array.isArray(filterArray)) {
        const result = [];
        for (const item of filterArray) {
            const oldValue = this.getState(action.item);
            this.setState(action.item, item);
            
            const condition = this.evaluateExpression(action.condition);
            if (condition) {
                result.push(item);
            }
            
            if (oldValue !== undefined) this.setState(action.item, oldValue);
        }
        if (action.storeIn) {
            this.setState(action.storeIn, result);
        }
        return result;
    }
}

async function arrayLength(action, event) {
    const array = this.resolveValue(action.array);
    const length = Array.isArray(array) ? array.length : 0;
    if (action.output) {
        this.setState(action.output, length);
    }
    return length;
}

// =====================================================
// „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÊìç‰Ωú„Ç¢„ÇØ„Ç∑„Éß„É≥
// =====================================================

async function objectSet(action, event) {
    const obj = this.resolveValue(action.object) || {};
    obj[action.key] = this.resolveValue(action.value);
    if (action.storeIn) {
        this.setState(action.storeIn, obj);
    }
}

async function objectGet(action, event) {
    const getObj = this.resolveValue(action.object);
    const value = getObj ? getObj[action.key] : undefined;
    if (action.storeIn) {
        this.setState(action.storeIn, value);
    }
    return value;
}

// =====================================================
// ÊñáÂ≠óÂàóÊìç‰Ωú„Ç¢„ÇØ„Ç∑„Éß„É≥
// =====================================================

async function stringTemplate(action, event) {
    const templated = this.resolveTemplate(action.template);
    if (action.storeIn) {
        this.setState(action.storeIn, templated);
    }
    return templated;
}

async function stringConcat(action, event) {
    const parts = action.parts.map(p => this.resolveTemplate(p));
    const concatenated = parts.join(action.separator || '');
    if (action.storeIn) {
        this.setState(action.storeIn, concatenated);
    }
    return concatenated;
}

// =====================================================
// „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£„Ç¢„ÇØ„Ç∑„Éß„É≥
// =====================================================

async function utilParseJSON(action, event) {
    const jsonString = this.resolveTemplate(action.json);
    
    // Á©∫ÊñáÂ≠óÂàó„ÇÑundefined„ÅÆÂ†¥Âêà„ÅØnull„ÇíËøî„Åô
    if (!jsonString || jsonString === 'undefined' || jsonString === 'null') {
        console.warn('‚ö†Ô∏è utilParseJSON: JSON„Éá„Éº„Çø„ÅåÁ©∫„Åß„Åô', { jsonString });
        if (action.output) {
            this.setState(action.output, null);
        }
        return null;
    }
    
    try {
        const parsed = JSON.parse(jsonString);
        if (action.output) {
            this.setState(action.output, parsed);
        }
        return parsed;
    } catch (error) {
        console.error('‚ùå JSON parse error:', error, { jsonString });
        if (action.output) {
            this.setState(action.output, null);
        }
        return null;
    }
}

async function utilTimestamp(action, event) {
    const timestamp = Date.now();
    if (action.output) {
        this.setState(action.output, timestamp);
    }
    return timestamp;
}

async function utilDelay(action, event) {
    const ms = action.ms || 100;
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function utilGetAttribute(action, event) {
    let targetElement = this.resolveValue(action.target);
    
    // {{event.currentTarget}}„ÅÆ„Çà„ÅÜ„Å™Â†¥Âêà„ÄÅevent„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åã„ÇâÁõ¥Êé•ÂèñÂæó
    if (!targetElement && typeof action.target === 'string' && event) {
        const eventMatch = action.target.match(/^\{\{event\.(.+)\}\}$/);
        if (eventMatch) {
            const path = eventMatch[1];
            const keys = path.split('.');
            targetElement = event[keys[0]];
            for (let i = 1; i < keys.length; i++) {
                if (targetElement && typeof targetElement === 'object') {
                    targetElement = targetElement[keys[i]];
                } else {
                    targetElement = undefined;
                    break;
                }
            }
        }
    }
    
    // attribute === 'closest' „ÅÆÂ†¥Âêà„ÅØ closest() „É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„Åô
    if (action.attribute === 'closest' && targetElement && targetElement.closest) {
        const closestElement = targetElement.closest(action.selector);
        if (action.output) {
            this.setState(action.output, closestElement);
        }
        return closestElement;
    }
    
    // ÈÄöÂ∏∏„ÅÆ getAttribute
    if (targetElement && targetElement.getAttribute) {
        const attrValue = targetElement.getAttribute(action.name || action.attribute);
        if (action.output) {
            this.setState(action.output, attrValue);
        }
        return attrValue;
    }
    
    console.warn('‚ö†Ô∏è utilGetAttribute: Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ„Åã„ÄÅ„É°„ÇΩ„ÉÉ„Éâ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', {
        target: action.target,
        resolvedElement: targetElement,
        event: event
    });
    return null;
}

async function utilClosest(action, event) {
    let targetElement = this.resolveValue(action.target);
    
    // {{event.currentTarget}}„ÅÆ„Çà„ÅÜ„Å™Â†¥Âêà
    if (!targetElement && typeof action.target === 'string' && event) {
        const eventMatch = action.target.match(/^\{\{event\.(.+)\}\}$/);
        if (eventMatch) {
            const path = eventMatch[1];
            const keys = path.split('.');
            targetElement = event[keys[0]];
            for (let i = 1; i < keys.length; i++) {
                if (targetElement && typeof targetElement === 'object') {
                    targetElement = targetElement[keys[i]];
                }
            }
        }
    }
    
    if (targetElement && targetElement.closest) {
        const closestElement = targetElement.closest(action.selector);
        if (action.output) {
            this.setState(action.output, closestElement);
        }
        return closestElement;
    }
    
    console.warn('‚ö†Ô∏è utilClosest: Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ„Åã„ÄÅclosest„É°„ÇΩ„ÉÉ„Éâ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', {
        target: action.target,
        selector: action.selector
    });
    return null;
}

async function utilQuerySelector(action, event) {
    let parent = this.resolveValue(action.parent);
    
    // {{event.currentTarget}}„ÅÆ„Çà„ÅÜ„Å™Â†¥Âêà„ÄÅevent„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åã„ÇâÁõ¥Êé•ÂèñÂæó
    if (!parent && typeof action.parent === 'string' && event) {
        const eventMatch = action.parent.match(/^\{\{event\.(.+)\}\}$/);
        if (eventMatch) {
            const path = eventMatch[1];
            const keys = path.split('.');
            parent = event[keys[0]];
            for (let i = 1; i < keys.length; i++) {
                if (parent && typeof parent === 'object') {
                    parent = parent[keys[i]];
                } else {
                    parent = undefined;
                    break;
                }
            }
        }
    }
    
    if (parent && parent.querySelector) {
        const element = parent.querySelector(action.selector);
        if (action.output) {
            this.setState(action.output, element);
        }
        return element;
    }
    console.warn('‚ö†Ô∏è utilQuerySelector: Ë¶™Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ„Åã„ÄÅquerySelector„É°„ÇΩ„ÉÉ„Éâ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', {
        parent: action.parent,
        selector: action.selector,
        resolvedParent: parent
    });
    return null;
}

// =====================================================
// „ÉÜ„É≥„Éó„É¨„Éº„Éà„Éª„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Ç¢„ÇØ„Ç∑„Éß„É≥
// =====================================================

async function templateRenderFromJSON(action, event) {
    const templateData = this.resolveValue(action.template);
    const renderedElement = this.renderComponentFromJSON(templateData);
    if (action.output) {
        this.setState(action.output, renderedElement);
    }
    return renderedElement;
}

async function componentRenderList(action, event) {
    const componentsData = this.resolveValue(action.components);
    const iconMapData = this.resolveValue(action.iconMap);
    const categoryName = this.resolveTemplate(action.categoryName || '');
    const isShared = action.isShared || false;
    
    const categoryElement = this.createComponentCategory(
        categoryName,
        componentsData,
        iconMapData,
        isShared
    );
    
    if (action.output) {
        this.setState(action.output, categoryElement);
    }
    return categoryElement;
}

async function componentMethod(action, event) {
    const methodName = this.resolveTemplate(action.method);
    const params = {};
    
    // params„ÇíËß£Ê±∫
    if (action.params) {
        for (const [key, value] of Object.entries(action.params)) {
            params[key] = this.resolveValue(value);
        }
    }
    
    // „É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„Åô
    const result = await this.callMethod(methodName, params);
    
    if (action.output) {
        this.setState(action.output, result);
    }
    
    return result;
}

async function registerComponentMethods(action, event) {
    const components = this.resolveValue(action.components);
    
    if (!components || !Array.isArray(components)) {
        console.warn('‚ö†Ô∏è „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÈÖçÂàó„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
        return;
    }
    
    let registeredCount = 0;
    
    components.forEach(component => {
        if (component.behavior && component.behavior.methods) {
            const componentName = component.name || component.type;
            
            for (const [methodName, methodDef] of Object.entries(component.behavior.methods)) {
                // „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÂêç„Çí„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„Å®„Åó„Å¶‰ªò„Åë„Åü„É°„ÇΩ„ÉÉ„ÉâÂêç„ÅßÁôªÈå≤
                const fullMethodName = `${componentName}.${methodName}`;
                
                if (!this.methods) {
                    this.methods = {};
                }
                
                this.methods[fullMethodName] = methodDef;
                
                // „Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„Å™„Åó„Åß„ÇÇÁôªÈå≤Ôºà„É°„ÇΩ„ÉÉ„ÉâÂêç„ÅÆË°ùÁ™Å„Å´Ê≥®ÊÑèÔºâ
                if (!this.methods[methodName]) {
                    this.methods[methodName] = methodDef;
                }
                
                registeredCount++;
            }
        }
    });
    
    console.log(`‚úÖ ${registeredCount}ÂÄã„ÅÆ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„É°„ÇΩ„ÉÉ„Éâ„ÇíÁôªÈå≤„Åó„Åæ„Åó„Åü`);
}

async function registerComponentActions(action, event) {
    const components = this.resolveValue(action.components);
    
    if (!components || !Array.isArray(components)) {
        console.warn('‚ö†Ô∏è „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÈÖçÂàó„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
        return;
    }
    
    let registeredCount = 0;
    
    components.forEach(component => {
        if (component.behavior && component.behavior.actions) {
            const componentName = component.name || component.type || 'unknown';
            
            for (const [actionName, actionDef] of Object.entries(component.behavior.actions)) {
                // „Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÁôªÈå≤
                this.registerAction(actionName, async (params) => {
                    console.log(`üéØ „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Ç¢„ÇØ„Ç∑„Éß„É≥ÂÆüË°å: ${actionName} (from ${componentName})`);
                    const event = params && params.event;
                    await this.executeAction(actionDef, event);
                });
                
                registeredCount++;
                console.log(`üì¶ „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Ç¢„ÇØ„Ç∑„Éß„É≥ÁôªÈå≤: ${actionName} (from ${componentName})`);
            }
        }
    });
    
    if (registeredCount > 0) {
        console.log(`‚úÖ ${registeredCount}ÂÄã„ÅÆ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÁôªÈå≤„Åó„Åæ„Åó„Åü`);
    }
}

// =====================================================
// „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Ç¢„ÇØ„Ç∑„Éß„É≥
// =====================================================

async function dragSetData(action, event) {
    if (event && event.dataTransfer) {
        const dragData = this.resolveValue(action.data);
        event.dataTransfer.effectAllowed = action.effectAllowed || 'copy';
        event.dataTransfer.setData('application/json', JSON.stringify(dragData));
    }
}

async function dragGetData(action, event) {
    if (event && event.dataTransfer) {
        const dragData = event.dataTransfer.getData('application/json');
        const parsedData = dragData ? JSON.parse(dragData) : null;
        if (action.output) {
            this.setState(action.output, parsedData);
        }
        return parsedData;
    }
}

// =====================================================
// „Éò„É´„Éë„Éº„É°„ÇΩ„ÉÉ„Éâ
// =====================================================

/**
 * „Éò„É´„Éë„Éº„É°„ÇΩ„ÉÉ„Éâ„ÇíJsoniaRuntime„Å´ËøΩÂä†
 */
function addHelperMethods(JsoniaRuntimeClass) {
    /**
     * JSON„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÂÆöÁæ©„Åã„ÇâDOMË¶ÅÁ¥†„Çí„É¨„É≥„ÉÄ„É™„É≥„Ç∞
     */
    JsoniaRuntimeClass.prototype.renderComponentFromJSON = function(componentData, childrenToInsert = null) {
        // extendsÂá¶ÁêÜ: ÂÖ±Êúâ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÇíÁ∂ôÊâø
        if (componentData.extends) {
            console.log('üîÑ extendsÊ§úÁü•:', componentData.extends);
            const baseComponentName = componentData.extends;
            const baseComponent = this.loadSharedComponent(baseComponentName);
            console.log('üì¶ „Éô„Éº„Çπ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà:', baseComponent);
            
            if (baseComponent && baseComponent.template) {
                console.log('‚úÖ „ÉÜ„É≥„Éó„É¨„Éº„ÉàÁô∫Ë¶ã„ÄÅ„Éû„Éº„Ç∏ÈñãÂßã');
                // „Éô„Éº„Çπ„ÉÜ„É≥„Éó„É¨„Éº„Éà„Çí„Éá„Ç£„Éº„Éó„Ç≥„Éî„Éº
                const mergedTemplate = JSON.parse(JSON.stringify(baseComponent.template));
                
                // „Ç™„Éº„Éê„Éº„É©„Ç§„Éâ: attributes
                if (componentData.attributes) {
                    mergedTemplate.attributes = {
                        ...mergedTemplate.attributes,
                        ...componentData.attributes
                    };
                }
                
                // „Ç™„Éº„Éê„Éº„É©„Ç§„Éâ: headerÈÉ®ÂàÜ
                if (componentData.header) {
                    const headerElement = this.findElementByPath(mergedTemplate, '[data-accordion-header]');
                    if (headerElement && componentData.header.text) {
                        const textSpan = headerElement.children.find(c => !c.attributes || !c.attributes.class || !c.attributes.class.includes('accordion-icon'));
                        if (textSpan) {
                            textSpan.text = componentData.header.text;
                        }
                    }
                }
                
                // „Ç™„Éº„Éê„Éº„É©„Ç§„Éâ: contentÈÉ®ÂàÜ
                if (componentData.content) {
                    const contentElement = this.findElementByPath(mergedTemplate, '[data-accordion-content]');
                    if (contentElement) {
                        if (componentData.content.id) {
                            contentElement.attributes.id = componentData.content.id;
                        }
                        if (componentData.content.children) {
                            contentElement.children = componentData.content.children;
                        }
                    }
                }
                
                // „Éû„Éº„Ç∏„Åï„Çå„Åü„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÅßÂÜçÂ∏∞„É¨„É≥„ÉÄ„É™„É≥„Ç∞
                return this.renderComponentFromJSON(mergedTemplate, childrenToInsert);
            } else {
                console.warn(`‚ö†Ô∏è ÂÖ±Êúâ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà "${baseComponentName}" „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
                console.log('üìã Âà©Áî®ÂèØËÉΩ„Å™„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà:', this.getState('sharedComponents'));
                // Á∂ôÊâøÂ§±ÊïóÊôÇ„ÅØÈÄöÂ∏∏„ÅÆÂá¶ÁêÜ„Å´ fallback
            }
        }
        
        const template = componentData.template || componentData;
        console.log('üèóÔ∏è „É¨„É≥„ÉÄ„É™„É≥„Ç∞:', template.tag, template.attributes);
        const element = document.createElement(template.tag || 'div');
        
        // „Çπ„É≠„ÉÉ„ÉàË¶ÅÁ¥†„ÇíË¶ã„Å§„Åë„ÇãÂ§âÊï∞
        let slotElement = null;
        
        // Â±ûÊÄß„ÇíË®≠ÂÆö
        if (template.attributes) {
            Object.entries(template.attributes).forEach(([key, value]) => {
                if (key === 'style' && typeof value === 'object') {
                    Object.assign(element.style, value);
                } else if (key === 'style' && typeof value === 'string') {
                    // „Ç®„Éá„Ç£„Çø„É¢„Éº„Éâ„Åß„ÅØ display: none „ÇíÁÑ°ÂäπÂåñ
                    const className = template.attributes.class || '';
                    const isHiddenContent = className.includes('accordion-content') || 
                                          className.includes('tab-panel') || 
                                          className.includes('modal-body');
                    
                    if (isHiddenContent) {
                        const styleWithoutHidden = value.replace(/display\s*:\s*none\s*;?/gi, '');
                        element.setAttribute(key, styleWithoutHidden);
                    } else {
                        element.setAttribute(key, value);
                    }
                } else {
                    element.setAttribute(key, value);
                }
            });
        }
        
        // Â≠êË¶ÅÁ¥†„ÇíÂÜçÂ∏∞ÁöÑ„Å´ËøΩÂä†„Åó„ÄÅ„Çπ„É≠„ÉÉ„ÉàË¶ÅÁ¥†„ÇíÊé¢„Åô
        if (template.children && Array.isArray(template.children)) {
            template.children.forEach((child, index) => {
                const childElement = this.renderComponentFromJSON(child);
                element.appendChild(childElement);
                
                // data-slot="children" „ÇíÊåÅ„Å§Ë¶ÅÁ¥†„Çí„Çπ„É≠„ÉÉ„Éà„Å®„Åó„Å¶Ë®òÊÜ∂
                if (child.attributes && child.attributes['data-slot'] === 'children') {
                    slotElement = childElement;
                    console.log('üéØ „Çπ„É≠„ÉÉ„ÉàË¶ÅÁ¥†Áô∫Ë¶ã(Áõ¥Êé•):', {
                        index: index,
                        className: childElement.className,
                        element: childElement
                    });
                }
                // ÂÜçÂ∏∞ÁöÑ„Å´„Çπ„É≠„ÉÉ„Éà„ÇíÊé¢„ÅôÔºà„Åæ„Å†Ë¶ã„Å§„Åã„Å£„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÔºâ
                if (!slotElement) {
                    const foundSlot = childElement.querySelector('[data-slot="children"]');
                    if (foundSlot) {
                        slotElement = foundSlot;
                        console.log('üéØ „Çπ„É≠„ÉÉ„ÉàË¶ÅÁ¥†Áô∫Ë¶ã(ÂÜçÂ∏∞):', {
                            index: index,
                            parentClassName: childElement.className,
                            slotClassName: foundSlot.className,
                            element: foundSlot
                        });
                    }
                }
            });
        }
        
        // „ÉÜ„Ç≠„Çπ„Éà„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÇíË®≠ÂÆö
        if (template.text && (!template.children || template.children.length === 0)) {
            element.textContent = template.text;
        }
        
        // Â§ñÈÉ®„Åã„ÇâÊ∏°„Åï„Çå„ÅüÂ≠êË¶ÅÁ¥†„Çí„Çπ„É≠„ÉÉ„Éà„Å´ÊåøÂÖ•
        if (childrenToInsert && childrenToInsert.length > 0) {
            const targetElement = slotElement || element;
            childrenToInsert.forEach(child => {
                targetElement.appendChild(child);
            });
        }
        
        // „Ç≥„É≥„ÉÜ„ÉäÂûã„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅÆÂ†¥Âêà„ÄÅÂÜÖÈÉ®„Éâ„É≠„ÉÉ„Éó„Çæ„Éº„É≥„ÇíËøΩÂä†
        const containerTypes = ['container', 'section', 'div', 'article', 'main', 'aside', 'nav', 'header', 'footer', 'form'];
        const componentType = componentData.type || template.tag;
        
        if (slotElement) {
            console.log('üìç „Çπ„É≠„ÉÉ„ÉàË¶ÅÁ¥†„Çí„Éâ„É≠„ÉÉ„Éó„Çæ„Éº„É≥„Å®„Åó„Å¶Ë®≠ÂÆö:', {
                className: slotElement.className,
                tagName: slotElement.tagName,
                hasDataSlot: slotElement.hasAttribute('data-slot'),
                dataSlotValue: slotElement.getAttribute('data-slot'),
                element: slotElement
            });
            // „Çπ„É≠„ÉÉ„ÉàË¶ÅÁ¥†Ëá™‰Ωì„Çí„Éâ„É≠„ÉÉ„Éó„Çæ„Éº„É≥„Å´Ë®≠ÂÆö
            slotElement.setAttribute('data-drop-zone', 'true');
            slotElement.classList.add('slot-drop-zone');
            
            // „Çπ„É≠„ÉÉ„Éà„Å´„Éâ„É©„ÉÉ„Ç∞„Ç™„Éº„Éê„Éº„Ç§„Éô„É≥„Éà„ÇíËøΩÂä†
            slotElement.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = 'copy';
                }
                slotElement.classList.add('drag-over-slot');
            });
            
            slotElement.addEventListener('dragleave', (e) => {
                // Â≠êË¶ÅÁ¥†„Å∏„ÅÆÁßªÂãï„ÅØÁÑ°Ë¶ñ
                if (!slotElement.contains(e.relatedTarget)) {
                    slotElement.classList.remove('drag-over-slot');
                }
            });
            
            // „Çπ„É≠„ÉÉ„Éà„Å´„Éâ„É≠„ÉÉ„Éó„Ç§„Éô„É≥„Éà„ÇíËøΩÂä†
            slotElement.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                slotElement.classList.remove('drag-over-slot');
                
                // handleInnerDrop„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂÆüË°å
                const dropActions = this.getState('innerDropActions');
                if (dropActions) {
                    this.setState('currentDropZone', slotElement);
                    await this.executeActions(dropActions, e);
                }
            });
            
            // „Çπ„É≠„ÉÉ„Éà„ÅåÁ©∫„ÅÆÂ†¥Âêà„ÅØÂÜÖÈÉ®„Éâ„É≠„ÉÉ„Éó„Çæ„Éº„É≥„ÇíËøΩÂä†ÔºàË¶ñË¶öÁöÑ„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„ÉºÔºâ
            console.log('üîç „Çπ„É≠„ÉÉ„ÉàË¶ÅÁ¥†„ÅÆÂ≠êË¶ÅÁ¥†Êï∞„ÉÅ„Çß„ÉÉ„ÇØ:', {
                slotClassName: slotElement.className,
                childrenLength: slotElement.children.length,
                willCreateInnerDropZone: slotElement.children.length === 0
            });
            
            if (slotElement.children.length === 0) {
                console.log('‚úÖ ÂÜÖÈÉ®„Éâ„É≠„ÉÉ„Éó„Çæ„Éº„É≥„Çí‰ΩúÊàê„Åó„Åæ„Åô');
                const innerDropZone = document.createElement('div');
                innerDropZone.className = 'inner-drop-zone';
                innerDropZone.setAttribute('data-drop-zone', 'true');
                
                // ÂÜÖÈÉ®„Éâ„É≠„ÉÉ„Éó„Çæ„Éº„É≥„Å´„ÇÇ„Ç§„Éô„É≥„Éà„ÇíË®≠ÂÆö
                innerDropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (e.dataTransfer) {
                        e.dataTransfer.dropEffect = 'copy';
                    }
                });
                
                innerDropZone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation(); // ‰ªñ„ÅÆ„É™„Çπ„Éä„Éº„ÇíÂç≥Â∫ß„Å´„Éñ„É≠„ÉÉ„ÇØ
                    
                    // handleInnerDrop„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂÆüË°å
                    const dropActions = this.getState('innerDropActions');
                    if (dropActions) {
                        this.setState('currentDropZone', slotElement); // Ë¶™„Çπ„É≠„ÉÉ„Éà„Å´ËøΩÂä†
                        await this.executeActions(dropActions, e);
                    }
                });
                
                slotElement.appendChild(innerDropZone);
                console.log('üü£ ÂÜÖÈÉ®„Éâ„É≠„ÉÉ„Éó„Çæ„Éº„É≥„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü:', innerDropZone);
            } else {
                console.log('‚è≠Ô∏è  „Çπ„É≠„ÉÉ„ÉàË¶ÅÁ¥†„Å´Êó¢„Å´Â≠êË¶ÅÁ¥†„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅÂÜÖÈÉ®„Éâ„É≠„ÉÉ„Éó„Çæ„Éº„É≥„ÅØ‰ΩúÊàê„Åó„Åæ„Åõ„Çì');
            }
        } else {
            // „Çπ„É≠„ÉÉ„Éà„Åå„Å™„ÅÑÂ†¥Âêà„ÅØË≠¶Âëä„ÇíË°®Á§∫(„Ç≥„É≥„ÉÜ„Éä„Çø„Ç§„Éó„ÅÆÂ†¥Âêà„ÅÆ„Åø)
            if (containerTypes.includes(componentType)) {
                console.log('‚ö†Ô∏è „Çπ„É≠„ÉÉ„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ„Åì„ÅÆ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Å´„ÅØÂ≠êË¶ÅÁ¥†„ÇíËøΩÂä†„Åß„Åç„Åæ„Åõ„Çì„ÄÇ', {
                    componentType: componentType,
                    className: element.className
                });
            }
        }
        
        return element;
    };

    /**
     * Ë¶ÅÁ¥†ÂÜÖ„ÅÆ„Çπ„É≠„ÉÉ„Éà„ÇíÊ§úÁ¥¢
     * @param {HTMLElement} element - Ê§úÁ¥¢ÂØæË±°„ÅÆË¶ÅÁ¥†
     * @param {string} slotName - „Çπ„É≠„ÉÉ„ÉàÂêç („Éá„Éï„Ç©„É´„Éà: 'children')
     * @returns {HTMLElement|null} - Ë¶ã„Å§„Åã„Å£„Åü„Çπ„É≠„ÉÉ„ÉàË¶ÅÁ¥†
     */
    JsoniaRuntimeClass.prototype.findSlot = function(element, slotName = 'children') {
        // Ë¶ÅÁ¥†Ëá™‰Ωì„Åå„Çπ„É≠„ÉÉ„Éà„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        if (element.hasAttribute && element.hasAttribute('data-slot')) {
            const slot = element.getAttribute('data-slot');
            if (slot === slotName) {
                return element;
            }
        }
        
        // Â≠êË¶ÅÁ¥†„ÇíÂÜçÂ∏∞ÁöÑ„Å´Ê§úÁ¥¢
        const slotSelector = `[data-slot="${slotName}"]`;
        return element.querySelector(slotSelector);
    };

    /**
     * „Çπ„É≠„ÉÉ„Éà„Å´Â≠êË¶ÅÁ¥†„ÇíÊåøÂÖ•
     * @param {HTMLElement} container - „Ç≥„É≥„ÉÜ„ÉäË¶ÅÁ¥†
     * @param {HTMLElement|HTMLElement[]} children - ÊåøÂÖ•„Åô„ÇãÂ≠êË¶ÅÁ¥†
     * @param {string} slotName - „Çπ„É≠„ÉÉ„ÉàÂêç („Éá„Éï„Ç©„É´„Éà: 'children')
     * @returns {boolean} - ÊåøÂÖ•ÊàêÂäü„Åó„Åü„Åã
     */
    JsoniaRuntimeClass.prototype.insertIntoSlot = function(container, children, slotName = 'children') {
        const slot = this.findSlot(container, slotName);
        const target = slot || container;
        
        // ÈÖçÂàó„Åß„Å™„ÅÑÂ†¥Âêà„ÅØÈÖçÂàóÂåñ
        const childArray = Array.isArray(children) ? children : [children];
        
        childArray.forEach(child => {
            if (child && child.nodeType === Node.ELEMENT_NODE) {
                target.appendChild(child);
            }
        });
        
        return !!slot;
    };

    /**
     * DOM„ÉÑ„É™„Éº„ÇíHTMLÊñáÂ≠óÂàó„Å®„Åó„Å¶ÊßãÁØâ
     */
    JsoniaRuntimeClass.prototype.buildTreeHTML = function(element, level = 0, options = {}) {
        let html = '';
        
        // drop-zoneËá™‰Ωì„ÅØ„Çπ„Ç≠„ÉÉ„Éó
        if (element.id === 'drop-zone') {
            const children = element.children;
            for (let i = 0; i < children.length; i++) {
                html += this.buildTreeHTML(children[i], level, options);
            }
            return html;
        }
        
        // canvas-component „Åæ„Åü„ÅØ nested-component „É©„ÉÉ„Éë„Éº„ÅÆÂ†¥Âêà
        if (element.classList.contains('canvas-component') || element.classList.contains('nested-component')) {
            const componentId = element.getAttribute('data-component-id');
            const actualComponent = element.querySelector(':scope > :not(.delete-component-btn)');
            
            if (actualComponent) {
                const tagName = actualComponent.tagName.toLowerCase();
                const classList = actualComponent.className ? `.${actualComponent.className.split(' ').join('.')}` : '';
                const id = actualComponent.id ? `#${actualComponent.id}` : '';
                
                html += `<div class="tree-node" style="padding: 4px 0 4px ${level * 20}px; cursor: pointer; font-family: monospace; font-size: 13px;" data-component-id="${componentId}">`;
                html += `<span style="color: #0066cc;">&lt;${tagName}${id}${classList}&gt;</span>`;
                
                // „ÉÜ„Ç≠„Çπ„Éà„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÇíË°®Á§∫
                if (actualComponent.childNodes.length === 1 && actualComponent.childNodes[0].nodeType === 3) {
                    const text = actualComponent.textContent.trim();
                    if (text.length > 30) {
                        html += ` <span style="color: #666;">${text.substring(0, 30)}...</span>`;
                    } else if (text) {
                        html += ` <span style="color: #666;">${text}</span>`;
                    }
                }
                
                html += '</div>';
                
                // „Çπ„É≠„ÉÉ„ÉàÂÜÖ„ÅÆ„Éç„Çπ„Éà„Åï„Çå„Åü„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÇíÊ§úÁ¥¢
                const slotElements = actualComponent.querySelectorAll('[data-slot]');
                slotElements.forEach(slot => {
                    const nestedComponents = slot.querySelectorAll(':scope > .canvas-component, :scope > .nested-component');
                    nestedComponents.forEach(nested => {
                        html += this.buildTreeHTML(nested, level + 1, options);
                    });
                });
                
                // „Çπ„É≠„ÉÉ„Éà„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÁõ¥Êé•„ÅÆÂ≠êË¶ÅÁ¥†„ÇíÂá¶ÁêÜ(ÂæåÊñπ‰∫íÊèõÊÄß)
                if (slotElements.length === 0) {
                    const children = actualComponent.children;
                    for (let i = 0; i < children.length; i++) {
                        if (children[i].classList.contains('canvas-component') || children[i].classList.contains('nested-component')) {
                            html += this.buildTreeHTML(children[i], level + 1, options);
                        }
                    }
                }
            }
        }
        
        return html;
    };

    /**
     * „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Ç´„ÉÜ„Ç¥„É™„Çí‰ΩúÊàê
     */
    JsoniaRuntimeClass.prototype.createComponentCategory = function(categoryName, components, iconMap, isShared = false) {
        const section = document.createElement('div');
        section.className = 'component-category' + (isShared ? ' shared-components' : '');
        
        const header = document.createElement('div');
        header.className = 'component-category-header';
        header.textContent = categoryName;
        section.appendChild(header);
        
        components.forEach(comp => {
            const item = this.createComponentItem(comp, iconMap, isShared);
            section.appendChild(item);
        });
        
        return section;
    };

    /**
     * „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Ç¢„Ç§„ÉÜ„É†„Çí‰ΩúÊàê
     */
    JsoniaRuntimeClass.prototype.createComponentItem = function(component, iconMap, isShared = false) {
        const item = document.createElement('div');
        item.className = 'component-item' + (isShared ? ' shared-component' : '');
        item.draggable = true;
        item.setAttribute('data-component-type', component.type || component.tag);
        item.setAttribute('data-component', JSON.stringify(component));
        
        const icon = component.icon || iconMap[component.tag] || iconMap.default || '‚óºÔ∏è';
        const name = component.name || component.tag;
        const description = component.description || '';
        
        item.innerHTML = `
            <span class="component-icon">${icon}</span>
            <div class="component-info">
                <div class="component-name">${name}</div>
                ${description ? `<div class="component-description">${description}</div>` : ''}
            </div>
        `;
        
        // „Éâ„É©„ÉÉ„Ç∞„Ç§„Éô„É≥„Éà„Çí„Éê„Ç§„É≥„Éâ
        item.addEventListener('dragstart', async (e) => {
            const dragStartActions = this.getState('dragStartActions');
            if (dragStartActions) {
                await this.executeActions(dragStartActions, e);
            }
        });
        
        item.addEventListener('dragend', (e) => {
            e.currentTarget.style.opacity = '1';
        });
        
        return item;
    };

    /**
     * ÂÖ±Êúâ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Çí„É≠„Éº„Éâ
     */
    JsoniaRuntimeClass.prototype.loadSharedComponent = function(componentName) {
        const sharedComponents = this.getState('sharedComponents') || [];
        console.log('üîç ÂÖ±Êúâ„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÊ§úÁ¥¢:', componentName, '‰ª∂Êï∞:', sharedComponents.length);
        
        // components/„Éï„Ç©„É´„ÉÄ„ÅÆJSON„Éï„Ç°„Ç§„É´Âêç„ÅßÊ§úÁ¥¢ (accordion-with-behavior)
        const component = sharedComponents.find(c => {
            const fileName = componentName;
            const matches = (
                c.type === fileName || 
                c.name === fileName ||
                c.type === fileName.replace(/-/g, '') ||
                (c.template && c.template.attributes && c.template.attributes.class && c.template.attributes.class.includes(fileName))
            );
            if (matches) {
                console.log('‚úÖ „Éû„ÉÉ„ÉÅ:', c.name || c.type);
            }
            return matches;
        });
        
        if (!component) {
            console.log('üìã Âà©Áî®ÂèØËÉΩ:', sharedComponents.map(c => c.name || c.type));
        }
        
        return component;
    };

    /**
     * „ÉÜ„É≥„Éó„É¨„Éº„ÉàÂÜÖ„Åã„ÇâÊåáÂÆö„Åï„Çå„Åü„Çª„É¨„ÇØ„Çø„Å´‰∏ÄËá¥„Åô„ÇãË¶ÅÁ¥†„ÇíÊé¢„Åô
     */
    JsoniaRuntimeClass.prototype.findElementByPath = function(template, selector) {
        // data-accordion-header „Å™„Å©„ÅÆÂ±ûÊÄß„Çª„É¨„ÇØ„Çø„Å´ÂØæÂøú
        const match = selector.match(/\[([^\]]+)\]/);
        if (match) {
            const attrName = match[1];
            return this.findElementByAttribute(template, attrName);
        }
        return null;
    };

    /**
     * „ÉÜ„É≥„Éó„É¨„Éº„ÉàÂÜÖ„Åã„ÇâÊåáÂÆö„Åï„Çå„ÅüÂ±ûÊÄß„ÇíÊåÅ„Å§Ë¶ÅÁ¥†„ÇíÂÜçÂ∏∞ÁöÑ„Å´Êé¢„Åô
     */
    JsoniaRuntimeClass.prototype.findElementByAttribute = function(template, attrName) {
        if (template.attributes && template.attributes[attrName]) {
            return template;
        }
        if (template.children && Array.isArray(template.children)) {
            for (const child of template.children) {
                const found = this.findElementByAttribute(child, attrName);
                if (found) return found;
            }
        }
        return null;
    };
}

// „Ç∞„É≠„Éº„Éê„É´„Å´ÂÖ¨Èñã
if (typeof window !== 'undefined') {
    window.extendJsoniaRuntimeWithActions = extendJsoniaRuntimeWithActions;
    window.addJsoniaRuntimeHelpers = addHelperMethods;
    
    // JsoniaRuntime„ÅåÊó¢„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çå„Å∞„ÄÅ„Åô„Åê„Å´Êã°Âºµ„ÇíÈÅ©Áî®
    if (window.JsoniaRuntime) {
        extendJsoniaRuntimeWithActions(window.JsoniaRuntime);
        addHelperMethods(window.JsoniaRuntime);
    }
}
